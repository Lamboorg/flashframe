<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="theme-color" content="#1e1b4b">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="FlashFrame">
  <title>FlashFrame</title>
  <link rel="manifest" href="/manifest.json">
  <link rel="icon" type="image/png" sizes="192x192" href="/icon-192.png">
  <link rel="apple-touch-icon" href="/icon-192.png">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    html {
      background: #1e1b4b;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background: linear-gradient(135deg, #1e1b4b 0%, #4c1d95 50%, #7c3aed 100%);
      min-height: 100vh;
      min-height: -webkit-fill-available;
      color: white;
      overflow-x: hidden;
      padding-bottom: env(safe-area-inset-bottom, 0px);
      padding-left: env(safe-area-inset-left, 0px);
      padding-right: env(safe-area-inset-right, 0px);
      
      /* Disable web behaviors - feel more like native app */
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
      overscroll-behavior: none;
    }
    

    /* Allow text selection only in input fields */
    input, textarea {
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
      user-select: text;
      -webkit-touch-callout: default;
    }
    
    .container {
      max-width: 500px;
      margin: 0 auto;
      padding: 20px;
      padding-top: 15px;
      min-height: 100vh;
    }
    }
    
    /* Header */
    .header {
      text-align: center;
      margin-bottom: 20px;
    }
    
    .header h1 {
      font-size: 1.8rem;
      margin-bottom: 5px;
    }
    
    .header p {
      opacity: 0.7;
      font-size: 0.9rem;
    }
    
    /* Navigation Tabs */
    .nav-tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 20px;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    .nav-tab {
      background: rgba(255,255,255,0.15);
      border: none;
      color: white;
      padding: 10px 16px;
      border-radius: 20px;
      cursor: pointer;
      font-size: 0.85rem;
      transition: all 0.3s;
    }
    
    .nav-tab.active {
      background: white;
      color: #4c1d95;
      font-weight: 600;
    }
    
    .nav-tab:hover:not(.active) {
      background: rgba(255,255,255,0.25);
    }
    
    /* Deck Cards */
    .decks-view {
      display: none;
    }
    
    .decks-view.active {
      display: block;
    }
    
    .deck-card {
      background: rgba(255,255,255,0.1);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 12px;
      cursor: pointer;
      transition: all 0.3s;
      position: relative;
      backdrop-filter: blur(10px);
    }
    
    .deck-card:hover {
      background: rgba(255,255,255,0.2);
      transform: translateY(-2px);
    }
    
    .deck-card h3 {
      font-size: 1.1rem;
      margin-bottom: 8px;
      padding-right: 30px;
    }
    
    .deck-stats {
      display: flex;
      gap: 15px;
      font-size: 0.85rem;
      opacity: 0.8;
    }
    
    .due-badge {
      position: absolute;
      top: 15px;
      right: 15px;
      background: #f59e0b;
      color: #000;
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 0.75rem;
      font-weight: 700;
    }
    
    .due-badge.none {
      background: #10b981;
    }
    
    .deck-delete-btn {
      position: absolute;
      bottom: 15px;
      right: 15px;
      background: rgba(239, 68, 68, 0.2);
      border: none;
      color: #fca5a5;
      width: 32px;
      height: 32px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 1rem;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s;
      opacity: 0;
    }
    
    .deck-card:hover .deck-delete-btn {
      opacity: 1;
    }
    
    .deck-delete-btn:hover {
      background: #ef4444;
      color: white;
    }
    
    /* Study View */
    .study-view {
      display: none;
    }
    
    .study-view.active {
      display: block;
    }
    
    /* Progress Bar */
    .progress-container {
      margin-bottom: 15px;
    }
    
    .progress-bar {
      background: rgba(255,255,255,0.2);
      border-radius: 10px;
      height: 8px;
      overflow: hidden;
    }
    
    .progress-fill {
      background: linear-gradient(90deg, #f472b6, #facc15);
      height: 100%;
      transition: width 0.3s;
    }
    
    .progress-text {
      text-align: center;
      font-size: 0.8rem;
      opacity: 0.7;
      margin-top: 5px;
    }
    
    /* Mode Toggle */
    .mode-toggle {
      display: flex;
      gap: 8px;
      margin-bottom: 15px;
      justify-content: center;
    }
    
    .mode-btn {
      background: rgba(255,255,255,0.15);
      border: none;
      color: white;
      padding: 8px 14px;
      border-radius: 15px;
      cursor: pointer;
      font-size: 0.8rem;
      transition: all 0.3s;
    }
    
    .mode-btn.active {
      background: rgba(255,255,255,0.9);
      color: #4c1d95;
      font-weight: 600;
    }
    
    /* Flashcard */
    .flashcard-container {
      perspective: 1000px;
      margin-bottom: 20px;
    }
    
    .flashcard {
      width: 100%;
      height: 280px;
      position: relative;
      transform-style: preserve-3d;
      transition: transform 0.6s;
      cursor: pointer;
    }
    
    .flashcard.flipped {
      transform: rotateY(180deg);
    }
    
    .flashcard-face {
      position: absolute;
      width: 100%;
      height: 100%;
      backface-visibility: hidden;
      border-radius: 20px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 25px;
      text-align: center;
    }
    
    .flashcard-front {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      box-shadow: 0 20px 40px rgba(0,0,0,0.3);
    }
    
    .flashcard-back {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      transform: rotateY(180deg);
      box-shadow: 0 20px 40px rgba(0,0,0,0.3);
    }
    
    .card-category {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 1px;
      opacity: 0.7;
      background: rgba(255,255,255,0.2);
      padding: 4px 12px;
      border-radius: 10px;
      margin-bottom: 15px;
    }
    
    .card-content {
      font-size: 1.15rem;
      line-height: 1.5;
    }
    
    .card-label {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 1px;
      opacity: 0.6;
      margin-bottom: 10px;
    }
    
    /* Typing Mode */
    .typing-area {
      display: none;
      margin-bottom: 15px;
    }
    
    .typing-area.active {
      display: block;
    }
    
    .type-question-display {
      background: rgba(255,255,255,0.1);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 15px;
      text-align: center;
    }
    
    .type-question-display .card-category {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 1px;
      opacity: 0.7;
      background: rgba(255,255,255,0.2);
      padding: 4px 12px;
      border-radius: 10px;
      display: inline-block;
      margin-bottom: 10px;
    }
    
    .type-question-display .question-text {
      font-size: 1.1rem;
      line-height: 1.5;
    }
    
    .typing-input {
      width: 100%;
      padding: 15px;
      border-radius: 12px;
      border: 2px solid rgba(255,255,255,0.3);
      background: rgba(255,255,255,0.1);
      color: white;
      font-size: 1rem;
      outline: none;
      transition: all 0.3s;
    }
    
    .typing-input:focus {
      border-color: rgba(255,255,255,0.6);
      background: rgba(255,255,255,0.15);
    }
    
    .typing-input::placeholder {
      color: rgba(255,255,255,0.5);
    }
    
    .check-btn {
      width: 100%;
      padding: 12px;
      border-radius: 12px;
      border: none;
      background: #10b981;
      color: white;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      margin-top: 10px;
      transition: all 0.3s;
    }
    
    .check-btn:hover {
      background: #059669;
    }
    
    .check-btn:disabled {
      background: #6b7280;
      cursor: not-allowed;
    }
    
    .result-feedback {
      display: none;
      padding: 15px;
      border-radius: 12px;
      margin-top: 10px;
      text-align: center;
    }
    
    .result-feedback.show {
      display: block;
      background: rgba(255,255,255,0.1);
      border: 2px solid rgba(255,255,255,0.3);
    }
    
    .your-answer {
      font-size: 0.85rem;
      opacity: 0.7;
      margin-bottom: 8px;
    }
    
    .correct-answer {
      font-size: 1rem;
      padding: 10px;
      background: rgba(255,255,255,0.1);
      border-radius: 8px;
      margin-top: 5px;
    }
    
    /* Controls */
    .controls {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 15px;
      margin-bottom: 15px;
    }
    
    .control-btn {
      background: rgba(255,255,255,0.2);
      border: none;
      color: white;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s;
      font-size: 1.2rem;
    }
    
    .control-btn:hover {
      background: rgba(255,255,255,0.3);
      transform: scale(1.1);
    }
    
    .control-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }
    
    /* SRS Buttons */
    .srs-controls {
      display: flex;
      gap: 8px;
      justify-content: center;
      flex-wrap: wrap;
    }
    
    .srs-btn {
      padding: 12px 18px;
      border-radius: 12px;
      border: none;
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: 600;
      transition: all 0.3s;
    }
    
    .srs-btn.again {
      background: #ef4444;
      color: white;
    }
    
    .srs-btn.hard {
      background: #f59e0b;
      color: #000;
    }
    
    .srs-btn.good {
      background: #10b981;
      color: white;
    }
    
    .srs-btn.easy {
      background: #3b82f6;
      color: white;
    }
    
    .srs-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    }
    
    .srs-btn span {
      display: block;
      font-size: 0.7rem;
      font-weight: 400;
      opacity: 0.8;
      margin-top: 2px;
    }
    
    /* Import View */
    .import-view {
      display: none;
    }
    
    .import-view.active {
      display: block;
    }
    
    .import-section {
      background: rgba(255,255,255,0.1);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 15px;
    }
    
    .import-section h3 {
      margin-bottom: 10px;
      font-size: 1rem;
    }
    
    .import-section p {
      font-size: 0.85rem;
      opacity: 0.7;
      margin-bottom: 15px;
    }
    
    .import-textarea {
      width: 100%;
      height: 150px;
      padding: 12px;
      border-radius: 10px;
      border: 2px solid rgba(255,255,255,0.2);
      background: rgba(0,0,0,0.2);
      color: white;
      font-size: 0.9rem;
      font-family: monospace;
      resize: vertical;
      outline: none;
    }
    
    .import-textarea:focus {
      border-color: rgba(255,255,255,0.4);
    }
    
    .import-textarea::placeholder {
      color: rgba(255,255,255,0.4);
    }
    
    .deck-name-input {
      width: 100%;
      padding: 12px;
      border-radius: 10px;
      border: 2px solid rgba(255,255,255,0.2);
      background: rgba(0,0,0,0.2);
      color: white;
      font-size: 0.95rem;
      margin-bottom: 10px;
      outline: none;
    }
    
    .deck-name-input:focus {
      border-color: rgba(255,255,255,0.4);
    }
    
    .import-btn {
      width: 100%;
      padding: 14px;
      border-radius: 12px;
      border: none;
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .import-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 20px rgba(0,0,0,0.2);
    }
    
    /* Settings */
    .settings-view {
      display: none;
    }
    
    .settings-view.active {
      display: block;
    }
    
    .setting-item {
      background: rgba(255,255,255,0.1);
      border-radius: 12px;
      padding: 15px;
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .setting-label {
      font-size: 0.95rem;
    }
    
    .setting-label span {
      display: block;
      font-size: 0.8rem;
      opacity: 0.6;
      margin-top: 3px;
    }
    
    .toggle-switch {
      width: 50px;
      height: 28px;
      background: rgba(255,255,255,0.2);
      border-radius: 14px;
      position: relative;
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .toggle-switch.active {
      background: #10b981;
    }
    
    .toggle-switch::after {
      content: '';
      position: absolute;
      width: 22px;
      height: 22px;
      background: white;
      border-radius: 50%;
      top: 3px;
      left: 3px;
      transition: all 0.3s;
    }
    
    .toggle-switch.active::after {
      left: 25px;
    }
    
    .danger-btn {
      background: #ef4444;
      color: white;
      border: none;
      padding: 12px 20px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 600;
      width: 100%;
      margin-top: 20px;
    }
    
    /* Back Button */
    .back-btn {
      background: rgba(255,255,255,0.15);
      border: none;
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      cursor: pointer;
      font-size: 0.85rem;
      margin-bottom: 15px;
      display: inline-flex;
      align-items: center;
      gap: 5px;
    }
    
    .back-btn:hover {
      background: rgba(255,255,255,0.25);
    }
    
    /* Empty State */
    .empty-state {
      text-align: center;
      padding: 40px 20px;
      opacity: 0.7;
    }
    
    .empty-state p {
      margin-bottom: 15px;
    }
    
    /* Footer */
    .footer-credit {
      text-align: center;
      padding: 30px 20px 20px;
      font-size: 0.75rem;
      opacity: 0.5;
      margin-top: auto;
    }
    
    /* Toast */
    .toast {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%) translateY(100px);
      background: rgba(0,0,0,0.9);
      color: white;
      padding: 12px 24px;
      border-radius: 10px;
      font-size: 0.9rem;
      transition: transform 0.3s;
      z-index: 1000;
    }
    
    .toast.show {
      transform: translateX(-50%) translateY(0);
    }
    
    /* Completed State */
    .completed-state {
      display: none;
      text-align: center;
      padding: 40px 20px;
    }
    
    .completed-state.active {
      display: block;
    }
    
    .completed-state h2 {
      font-size: 2rem;
      margin-bottom: 10px;
    }
    
    .completed-state p {
      opacity: 0.8;
      margin-bottom: 20px;
    }
    
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin: 20px 0;
    }
    
    .stat-box {
      background: rgba(255,255,255,0.1);
      border-radius: 12px;
      padding: 15px;
    }
    
    .stat-box .number {
      font-size: 1.8rem;
      font-weight: 700;
    }
    
    .stat-box .label {
      font-size: 0.8rem;
      opacity: 0.7;
    }
    
    /* Shuffle indicator */
    .shuffle-indicator {
      font-size: 0.8rem;
      opacity: 0.6;
      text-align: center;
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üìö FlashFrame</h1>
      <p>Tap cards to flip ‚Ä¢ Swipe to navigate</p>
    </div>
    
    <!-- Navigation -->
    <div class="nav-tabs">
      <button class="nav-tab active" data-view="decks">Decks</button>
      <button class="nav-tab" data-view="import">Import</button>
      <button class="nav-tab" data-view="settings">Settings</button>
    </div>
    
    <!-- Decks View -->
    <div class="decks-view active" id="decks-view">
      <div id="decks-list"></div>
    </div>
    
    <!-- Study View -->
    <div class="study-view" id="study-view">
      <button class="back-btn" onclick="showDecks()">‚Üê Back to Decks</button>
      
      <div class="progress-container">
        <div class="progress-bar">
          <div class="progress-fill" id="progress-fill"></div>
        </div>
        <p class="progress-text" id="progress-text">Card 1 of 20</p>
      </div>
      
      <div class="mode-toggle">
        <button class="mode-btn active" data-mode="flip">Flip Mode</button>
        <button class="mode-btn" data-mode="type">Type Mode</button>
      </div>
      
      <div class="shuffle-indicator" id="shuffle-indicator"></div>
      
      <div class="flashcard-container" id="flashcard-container">
        <div class="flashcard" id="flashcard" onclick="flipCard()">
          <div class="flashcard-face flashcard-front">
            <div class="card-category" id="card-category">Category</div>
            <div class="card-content" id="card-question">Question goes here</div>
          </div>
          <div class="flashcard-face flashcard-back">
            <div class="card-label">Answer</div>
            <div class="card-content" id="card-answer">Answer goes here</div>
          </div>
        </div>
      </div>
      
      <div class="typing-area" id="typing-area">
        <div class="type-question-display" id="type-question-display">
          <div class="card-category" id="type-category">Category</div>
          <div class="question-text" id="type-question">Question goes here</div>
        </div>
        <input type="text" class="typing-input" id="typing-input" placeholder="Type your answer..." autocomplete="off">
        <button class="check-btn" id="check-btn" onclick="checkAnswer()">Check Answer</button>
        <div class="result-feedback" id="result-feedback">
          <div class="your-answer" id="your-answer">Your answer: </div>
          <div class="correct-answer" id="correct-answer">Correct answer: </div>
        </div>
      </div>
      
      <div class="controls">
        <button class="control-btn" onclick="shuffleCards()" title="Shuffle">üîÄ</button>
      </div>
      
      <div class="srs-controls" id="srs-controls">
        <button class="srs-btn again" onclick="rateSRS(0)">Again<span>1m</span></button>
        <button class="srs-btn hard" onclick="rateSRS(1)">Hard<span id="hard-interval">6m</span></button>
        <button class="srs-btn good" onclick="rateSRS(2)">Good<span id="good-interval">10m</span></button>
        <button class="srs-btn easy" onclick="rateSRS(3)">Easy<span id="easy-interval">4d</span></button>
      </div>
      
      <!-- Completed State -->
      <div class="completed-state" id="completed-state">
        <h2>üéâ All Done!</h2>
        <p>You've completed this study session</p>
        <div class="stats-grid">
          <div class="stat-box">
            <div class="number" id="stat-total">0</div>
            <div class="label">Cards Studied</div>
          </div>
          <div class="stat-box">
            <div class="number" id="stat-correct">0</div>
            <div class="label">Correct</div>
          </div>
        </div>
        <button class="import-btn" onclick="showDecks()">Back to Decks</button>
      </div>
    </div>
    
    <!-- Import View -->
    <div class="import-view" id="import-view">
      <div class="import-section">
        <h3>üì• Import Flashcards</h3>
        <p>Format: question:answer (one per line)</p>
        <input type="text" class="deck-name-input" id="new-deck-name" placeholder="Deck name (e.g., Biology 101)">
        <textarea class="import-textarea" id="import-text" placeholder="What is the capital of France:Paris
What is 2+2:4
Who wrote Hamlet:William Shakespeare"></textarea>
        <button class="import-btn" onclick="importCards()">Import Cards</button>
      </div>
      
      <div class="import-section">
        <h3>üì§ Export All Data</h3>
        <p>Backup your flashcards and progress</p>
        <button class="import-btn" onclick="exportData()">Export Data</button>
      </div>
      
      <div class="import-section">
        <h3>üì• Restore from Backup</h3>
        <p>Paste your JSON backup data here:</p>
        <textarea class="import-textarea" id="restore-text" placeholder='Paste your backup JSON here...'></textarea>
        <button class="import-btn" onclick="restoreBackup()">Restore Backup</button>
      </div>
    </div>
    
    <!-- Settings View -->
    <div class="settings-view" id="settings-view">
      <div class="setting-item">
        <div class="setting-label">
          Shuffle by default
          <span>Randomize card order when studying</span>
        </div>
        <div class="toggle-switch" id="toggle-shuffle" onclick="toggleSetting('shuffle')"></div>
      </div>
      
      <div class="setting-item">
        <div class="setting-label">
          SRS Mode
          <span>Use spaced repetition system</span>
        </div>
        <div class="toggle-switch active" id="toggle-srs" onclick="toggleSetting('srs')"></div>
      </div>
      
      <div class="setting-item">
        <div class="setting-label">
          Show only due cards
          <span>Hide cards not due for review</span>
        </div>
        <div class="toggle-switch active" id="toggle-due-only" onclick="toggleSetting('dueOnly')"></div>
      </div>
      
      <button class="danger-btn" onclick="resetAllData()">Reset All Data</button>
    </div>
    
    <!-- Footer -->
    <div class="footer-credit">Made by Lamboorg with ‚ô° ‚Ä¢ v1.3</div>
    
    <!-- Toast -->
    <div class="toast" id="toast"></div>
  </div>

  <script>
    // ============ DATA ============
    const defaultDecks = {
      "Human Body": [
        { category: "Overall Facts", q: "How many atoms make up the human body?", a: "Approximately 7 octillion atoms" },
        { category: "Overall Facts", q: "How many total cells are in the human body?", a: "Over 75 trillion cells (~38-100 trillion microbial + ~37 trillion human cells)" },
        { category: "Overall Facts", q: "How many hairs are on a human head?", a: "100,000 to 150,000 hairs" },
        { category: "Body Elements", q: "How many elements make up the human body at an atomic level?", a: "60 elements (though the function of many is unknown)" },
        { category: "Body Elements", q: "What percentage of the body is made from just 6 elements?", a: "99% of the body" },
        { category: "Body Elements", q: "Why is the human body considered 'carbon-based'?", a: "The bio-molecules that make up our bodies are made of frameworks of carbon atoms" },
        { category: "Body Elements", q: "What is the most abundant mineral in the human body and what is it used for?", a: "Calcium ‚Äî used for protein regulation of production and activity" },
        { category: "Cell Facts", q: "Where do complex cascades of chemical reactions occur in cells?", a: "Within the gel-like cytoplasm and organelles of cells" },
        { category: "Cell Facts", q: "What is ATP and what element is used to make it?", a: "Adenosine triphosphate ‚Äî made using phosphorus. It has high-energy phosphate bonds that power cellular processes (cell fuel)" },
        { category: "Cell Facts", q: "How do cells respond to environmental changes?", a: "Cells are coated in receptors that respond through chemical signals and electrical impulses" },
        { category: "Cell Facts", q: "What role do chemical gradients play in embryonic development?", a: "They tell developing cells where to go and what type of cell to become" },
        { category: "Cell Facts", q: "Are the majority of cells in your body human?", a: "No! Microbes make up the majority and account for 1-3% of body mass" },
        { category: "Microbes", q: "What are the 5 types of microbes (microorganisms)?", a: "Bacteria, Viruses, Fungi, Archaea, and Protists" },
        { category: "Microbes", q: "Which microbe type is most common?", a: "Bacteria ‚Äî single-celled organisms" },
        { category: "Microbes", q: "What makes viruses unique among microbes?", a: "They require host cells to reproduce" },
        { category: "Microbes", q: "How are Archaea different from Bacteria?", a: "They're similar in structure but genetically different" },
        { category: "Cell Types", q: "What type of cells are human cells?", a: "Eukaryotic cells (complex, with a nucleus) containing human DNA" },
        { category: "Cell Types", q: "What type of cells are bacteria?", a: "Prokaryotic cells (simpler, no nucleus)" },
        { category: "Cell Types", q: "Are fungal cells eukaryotic or prokaryotic?", a: "Eukaryotic (but not human)" },
        { category: "Cell Types", q: "What type of cells are Archaea?", a: "Prokaryotic cells (each with its own DNA)" },
      ]
    };

    // ============ STATE ============
    let decks = {};
    let cardProgress = {}; // SRS data for each card
    let settings = {
      shuffle: false,
      srs: true,
      dueOnly: true
    };
    
    let currentDeck = null;
    let currentCards = [];
    let currentIndex = 0;
    let isFlipped = false;
    let studyMode = 'flip'; // 'flip' or 'type'
    let sessionStats = { total: 0, correct: 0 };

    // ============ INIT ============
    function init() {
      loadData();
      renderDecks();
      setupEventListeners();
      updateSettingsUI();
    }

    function loadData() {
      const savedDecks = localStorage.getItem('flashcards_decks');
      const savedProgress = localStorage.getItem('flashcards_progress');
      const savedSettings = localStorage.getItem('flashcards_settings');
      
      if (savedDecks) {
        decks = JSON.parse(savedDecks);
      } else {
        decks = { ...defaultDecks };
        saveDecks();
      }
      
      if (savedProgress) {
        cardProgress = JSON.parse(savedProgress);
      }
      
      if (savedSettings) {
        settings = JSON.parse(savedSettings);
      }
    }

    function saveDecks() {
      localStorage.setItem('flashcards_decks', JSON.stringify(decks));
    }

    function saveProgress() {
      localStorage.setItem('flashcards_progress', JSON.stringify(cardProgress));
    }

    function saveSettings() {
      localStorage.setItem('flashcards_settings', JSON.stringify(settings));
    }

    // ============ SRS LOGIC ============
    function getCardKey(deckName, card) {
      return `${deckName}::${card.q}`;
    }

    function getCardProgress(deckName, card) {
      const key = getCardKey(deckName, card);
      if (!cardProgress[key]) {
        cardProgress[key] = {
          interval: 0, // minutes
          easeFactor: 2.5,
          repetitions: 0,
          dueDate: Date.now(),
          lastReview: null
        };
      }
      return cardProgress[key];
    }

    function isCardDue(deckName, card) {
      const progress = getCardProgress(deckName, card);
      return Date.now() >= progress.dueDate;
    }

    function getDueCount(deckName) {
      const cards = decks[deckName] || [];
      return cards.filter(card => isCardDue(deckName, card)).length;
    }

    function calculateNextInterval(quality, progress) {
      // SM-2 Algorithm simplified
      // quality: 0 = Again, 1 = Hard, 2 = Good, 3 = Easy
      
      let { interval, easeFactor, repetitions } = progress;
      
      if (quality < 1) {
        // Again - reset
        repetitions = 0;
        interval = 1; // 1 minute
      } else {
        if (repetitions === 0) {
          interval = 1; // 1 minute
        } else if (repetitions === 1) {
          interval = 6; // 6 minutes
        } else {
          interval = Math.round(interval * easeFactor);
        }
        
        // Adjust ease factor
        easeFactor = Math.max(1.3, easeFactor + (0.1 - (3 - quality) * (0.08 + (3 - quality) * 0.02)));
        
        // Apply quality modifier
        if (quality === 1) interval = Math.round(interval * 0.8); // Hard
        if (quality === 3) interval = Math.round(interval * 1.5); // Easy
        
        repetitions++;
      }
      
      return { interval, easeFactor, repetitions };
    }

    function formatInterval(minutes) {
      if (minutes < 60) return `${minutes}m`;
      if (minutes < 1440) return `${Math.round(minutes / 60)}h`;
      return `${Math.round(minutes / 1440)}d`;
    }

    function updateSRSButtons(deckName, card) {
      const progress = getCardProgress(deckName, card);
      
      const againNext = calculateNextInterval(0, progress);
      const hardNext = calculateNextInterval(1, progress);
      const goodNext = calculateNextInterval(2, progress);
      const easyNext = calculateNextInterval(3, progress);
      
      document.getElementById('hard-interval').textContent = formatInterval(hardNext.interval);
      document.getElementById('good-interval').textContent = formatInterval(goodNext.interval);
      document.getElementById('easy-interval').textContent = formatInterval(easyNext.interval);
    }

    function rateSRS(quality) {
      if (!currentDeck || currentIndex >= currentCards.length) return;
      
      const card = currentCards[currentIndex];
      const key = getCardKey(currentDeck, card);
      const progress = getCardProgress(currentDeck, card);
      
      const next = calculateNextInterval(quality, progress);
      
      cardProgress[key] = {
        ...next,
        dueDate: Date.now() + (next.interval * 60 * 1000),
        lastReview: Date.now()
      };
      
      saveProgress();
      
      sessionStats.total++;
      if (quality >= 2) sessionStats.correct++;
      
      // Move to next card
      currentIndex++;
      if (currentIndex >= currentCards.length) {
        showCompleted();
      } else {
        updateStudyUI();
      }
    }

    // ============ UI ============
    function renderDecks() {
      const container = document.getElementById('decks-list');
      const deckNames = Object.keys(decks);
      
      if (deckNames.length === 0) {
        container.innerHTML = `
          <div class="empty-state">
            <p>No decks yet!</p>
            <p>Import some flashcards to get started.</p>
          </div>
        `;
        return;
      }
      
      container.innerHTML = deckNames.map(name => {
        const cards = decks[name];
        const dueCount = getDueCount(name);
        const escapedName = name.replace(/'/g, "\\'").replace(/"/g, '&quot;');
        return `
          <div class="deck-card" onclick="startStudy('${escapedName}')">
            <h3>${name}</h3>
            <div class="deck-stats">
              <span>üìö ${cards.length} cards</span>
            </div>
            <div class="due-badge ${dueCount === 0 ? 'none' : ''}">${dueCount === 0 ? '‚úì All done' : `${dueCount} due`}</div>
            <button class="deck-delete-btn" onclick="deleteDeck(event, '${escapedName}')" title="Delete deck">üóëÔ∏è</button>
          </div>
        `;
      }).join('');
    }
    
    function deleteDeck(event, deckName) {
      event.stopPropagation(); // Prevent starting study
      
      if (confirm(`Delete "${deckName}" and all its cards?\n\nThis cannot be undone.`)) {
        delete decks[deckName];
        
        // Also clean up progress for cards in this deck
        const keysToDelete = Object.keys(cardProgress).filter(key => key.startsWith(deckName + '::'));
        keysToDelete.forEach(key => delete cardProgress[key]);
        
        saveDecks();
        saveProgress();
        renderDecks();
        showToast(`"${deckName}" deleted`);
      }
    }

    function startStudy(deckName) {
      currentDeck = deckName;
      let cards = [...decks[deckName]];
      
      // Filter to due cards if setting enabled
      if (settings.dueOnly && settings.srs) {
        cards = cards.filter(card => isCardDue(deckName, card));
      }
      
      if (cards.length === 0) {
        showToast('No cards due for review! üéâ');
        return;
      }
      
      // Shuffle if enabled
      if (settings.shuffle) {
        cards = shuffleArray(cards);
      }
      
      currentCards = cards;
      currentIndex = 0;
      sessionStats = { total: 0, correct: 0 };
      
      showView('study');
      updateStudyUI();
    }

    function updateStudyUI() {
      if (currentIndex >= currentCards.length) {
        showCompleted();
        return;
      }
      
      const card = currentCards[currentIndex];
      
      // Update flip mode card
      document.getElementById('card-category').textContent = card.category || 'General';
      document.getElementById('card-question').textContent = card.q;
      document.getElementById('card-answer').textContent = card.a;
      
      // Update type mode question
      document.getElementById('type-category').textContent = card.category || 'General';
      document.getElementById('type-question').textContent = card.q;
      
      // Progress
      const progress = ((currentIndex + 1) / currentCards.length) * 100;
      document.getElementById('progress-fill').style.width = `${progress}%`;
      document.getElementById('progress-text').textContent = `Card ${currentIndex + 1} of ${currentCards.length}`;
      
      // Shuffle indicator
      document.getElementById('shuffle-indicator').textContent = settings.shuffle ? 'üîÄ Shuffled' : '';
      
      // Reset flip
      isFlipped = false;
      document.getElementById('flashcard').classList.remove('flipped');
      
      // Reset typing state
      if (studyMode === 'type') {
        resetTypingState();
      }
      
      // Update SRS buttons
      if (settings.srs) {
        updateSRSButtons(currentDeck, card);
      }
      
      // Show/hide SRS controls based on mode
      if (studyMode === 'flip') {
        document.getElementById('srs-controls').style.display = settings.srs ? 'flex' : 'none';
      } else {
        document.getElementById('srs-controls').style.display = 'none';
      }
      
      // Show/hide completed state
      document.getElementById('completed-state').classList.remove('active');
      document.getElementById('flashcard-container').style.display = studyMode === 'flip' ? 'block' : 'none';
    }

    function showCompleted() {
      document.getElementById('flashcard-container').style.display = 'none';
      document.getElementById('typing-area').classList.remove('active');
      document.getElementById('srs-controls').style.display = 'none';
      document.getElementById('completed-state').classList.add('active');
      
      document.getElementById('stat-total').textContent = sessionStats.total;
      document.getElementById('stat-correct').textContent = sessionStats.correct;
    }

    function flipCard() {
      if (studyMode === 'type' && !isFlipped) return;
      
      isFlipped = !isFlipped;
      document.getElementById('flashcard').classList.toggle('flipped', isFlipped);
    }

    function nextCard() {
      if (settings.srs && studyMode === 'flip') {
        // In SRS + flip mode, must flip first then use rating buttons
        if (!isFlipped) {
          flipCard();
          return;
        }
        // If flipped, user should use SRS buttons, so do nothing
        return;
      }
      
      if (settings.srs && studyMode === 'type') {
        // In SRS + type mode, user should use check answer then SRS buttons
        return;
      }
      
      // Non-SRS mode: just advance
      currentIndex++;
      if (currentIndex >= currentCards.length) {
        showCompleted();
      } else {
        updateStudyUI();
      }
    }

    function prevCard() {
      if (currentIndex > 0) {
        currentIndex--;
        updateStudyUI();
      }
    }

    function shuffleCards() {
      currentCards = shuffleArray([...currentCards]);
      currentIndex = 0;
      updateStudyUI();
      showToast('Cards shuffled! üîÄ');
    }

    function shuffleArray(array) {
      const arr = [...array];
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    // ============ TYPING MODE ============
    let answerRevealed = false;
    
    function setStudyMode(mode) {
      studyMode = mode;
      document.querySelectorAll('.mode-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.mode === mode);
      });
      
      const typingArea = document.getElementById('typing-area');
      const flashcardContainer = document.getElementById('flashcard-container');
      const srsControls = document.getElementById('srs-controls');
      
      if (mode === 'type') {
        typingArea.classList.add('active');
        flashcardContainer.style.display = 'none';
        srsControls.style.display = 'none';
        updateTypeQuestion();
        resetTypingState();
      } else {
        typingArea.classList.remove('active');
        flashcardContainer.style.display = 'block';
        srsControls.style.display = settings.srs ? 'flex' : 'none';
      }
    }
    
    function updateTypeQuestion() {
      if (currentIndex >= currentCards.length) return;
      const card = currentCards[currentIndex];
      document.getElementById('type-category').textContent = card.category || 'General';
      document.getElementById('type-question').textContent = card.q;
    }
    
    function resetTypingState() {
      answerRevealed = false;
      document.getElementById('typing-input').value = '';
      document.getElementById('typing-input').disabled = false;
      document.getElementById('check-btn').disabled = false;
      document.getElementById('result-feedback').classList.remove('show');
      document.getElementById('srs-controls').style.display = 'none';
    }

    function checkAnswer() {
      if (answerRevealed) return;
      
      const input = document.getElementById('typing-input').value.trim();
      const card = currentCards[currentIndex];
      
      // Show the answer
      answerRevealed = true;
      document.getElementById('typing-input').disabled = true;
      document.getElementById('check-btn').disabled = true;
      
      document.getElementById('your-answer').textContent = `Your answer: ${input || '(blank)'}`;
      document.getElementById('correct-answer').textContent = `Correct answer: ${card.a}`;
      document.getElementById('result-feedback').classList.add('show');
      
      // Show SRS buttons
      if (settings.srs) {
        updateSRSButtons(currentDeck, card);
        document.getElementById('srs-controls').style.display = 'flex';
      } else {
        // Auto advance after delay if SRS is off
        setTimeout(() => {
          currentIndex++;
          if (currentIndex >= currentCards.length) {
            showCompleted();
          } else {
            updateStudyUI();
          }
        }, 2000);
      }
    }



    // ============ IMPORT ============
    function importCards() {
      const deckName = document.getElementById('new-deck-name').value.trim();
      const text = document.getElementById('import-text').value.trim();
      
      if (!deckName) {
        showToast('Please enter a deck name');
        return;
      }
      
      if (!text) {
        showToast('Please enter some flashcards');
        return;
      }
      
      const lines = text.split('\n').filter(line => line.trim());
      const cards = [];
      
      for (const line of lines) {
        const parts = line.split(':');
        if (parts.length >= 2) {
          const q = parts[0].trim();
          const a = parts.slice(1).join(':').trim(); // Handle answers with colons
          if (q && a) {
            cards.push({ category: deckName, q, a });
          }
        }
      }
      
      if (cards.length === 0) {
        showToast('No valid cards found. Use format: question:answer');
        return;
      }
      
      // Add to existing deck or create new
      if (decks[deckName]) {
        decks[deckName] = [...decks[deckName], ...cards];
      } else {
        decks[deckName] = cards;
      }
      
      saveDecks();
      renderDecks();
      
      document.getElementById('new-deck-name').value = '';
      document.getElementById('import-text').value = '';
      
      showToast(`Imported ${cards.length} cards to "${deckName}"! üéâ`);
      showView('decks');
    }

    function exportData() {
      const data = {
        decks,
        progress: cardProgress,
        settings,
        exportDate: new Date().toISOString()
      };
      
      const jsonString = JSON.stringify(data, null, 2);
      const filename = `flashframe-backup-${new Date().toISOString().split('T')[0]}.json`;
      
      // Try Web Share API first (works on mobile)
      if (navigator.share && navigator.canShare) {
        const file = new File([jsonString], filename, { type: 'application/json' });
        if (navigator.canShare({ files: [file] })) {
          navigator.share({
            files: [file],
            title: 'FlashFrame Backup',
            text: 'My FlashFrame flashcards backup'
          }).then(() => {
            showToast('Data exported! üì§');
          }).catch((err) => {
            // If share fails, fallback to copy
            fallbackExport(jsonString);
          });
          return;
        }
      }
      
      // Try standard download
      try {
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        
        URL.revokeObjectURL(url);
        showToast('Data exported! üì§');
      } catch (e) {
        // Fallback to copy method
        fallbackExport(jsonString);
      }
    }
    
    function fallbackExport(jsonString) {
      // Copy to clipboard as fallback
      if (navigator.clipboard) {
        navigator.clipboard.writeText(jsonString).then(() => {
          showToast('Data copied to clipboard! üìã Paste into a .json file');
        }).catch(() => {
          showExportModal(jsonString);
        });
      } else {
        showExportModal(jsonString);
      }
    }
    
    function showExportModal(jsonString) {
      // Create a modal to display the data
      const modal = document.createElement('div');
      modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.9);z-index:9999;padding:20px;overflow:auto;';
      modal.innerHTML = `
        <div style="max-width:500px;margin:0 auto;">
          <h3 style="color:white;margin-bottom:10px;">üì§ Export Data</h3>
          <p style="color:rgba(255,255,255,0.7);margin-bottom:15px;font-size:0.9rem;">Copy this data and save it as a .json file:</p>
          <textarea id="export-textarea" style="width:100%;height:300px;padding:10px;border-radius:10px;font-family:monospace;font-size:12px;" readonly>${jsonString}</textarea>
          <button onclick="copyExportData()" style="width:100%;padding:15px;margin-top:10px;border:none;border-radius:10px;background:#10b981;color:white;font-weight:600;cursor:pointer;">Copy to Clipboard</button>
          <button onclick="this.parentElement.parentElement.remove()" style="width:100%;padding:15px;margin-top:10px;border:none;border-radius:10px;background:rgba(255,255,255,0.2);color:white;font-weight:600;cursor:pointer;">Close</button>
        </div>
      `;
      document.body.appendChild(modal);
    }
    
    function copyExportData() {
      const textarea = document.getElementById('export-textarea');
      textarea.select();
      document.execCommand('copy');
      showToast('Copied to clipboard! üìã');
    }
    
    function restoreBackup() {
      const text = document.getElementById('restore-text').value.trim();
      
      if (!text) {
        showToast('Please paste your backup data');
        return;
      }
      
      try {
        const data = JSON.parse(text);
        
        if (!data.decks) {
          showToast('Invalid backup format');
          return;
        }
        
        if (confirm('This will replace all your current data. Continue?')) {
          decks = data.decks;
          if (data.progress) cardProgress = data.progress;
          if (data.settings) settings = data.settings;
          
          saveDecks();
          saveProgress();
          saveSettings();
          
          renderDecks();
          updateSettingsUI();
          
          document.getElementById('restore-text').value = '';
          showToast('Backup restored! üéâ');
          showView('decks');
        }
      } catch (e) {
        showToast('Invalid JSON format');
      }
    }

    // ============ SETTINGS ============
    function toggleSetting(key) {
      settings[key] = !settings[key];
      saveSettings();
      updateSettingsUI();
    }

    function updateSettingsUI() {
      document.getElementById('toggle-shuffle').classList.toggle('active', settings.shuffle);
      document.getElementById('toggle-srs').classList.toggle('active', settings.srs);
      document.getElementById('toggle-due-only').classList.toggle('active', settings.dueOnly);
    }

    function resetAllData() {
      if (confirm('Are you sure? This will delete ALL your flashcards and progress!')) {
        localStorage.removeItem('flashcards_decks');
        localStorage.removeItem('flashcards_progress');
        localStorage.removeItem('flashcards_settings');
        location.reload();
      }
    }

    // ============ NAVIGATION ============
    function showView(view) {
      document.querySelectorAll('.nav-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.view === view);
      });
      
      document.getElementById('decks-view').classList.toggle('active', view === 'decks');
      document.getElementById('study-view').classList.toggle('active', view === 'study');
      document.getElementById('import-view').classList.toggle('active', view === 'import');
      document.getElementById('settings-view').classList.toggle('active', view === 'settings');
    }

    function showDecks() {
      renderDecks();
      showView('decks');
    }

    function showToast(message) {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), 2500);
    }

    // ============ EVENT LISTENERS ============
    function setupEventListeners() {
      // Nav tabs
      document.querySelectorAll('.nav-tab').forEach(tab => {
        tab.addEventListener('click', () => showView(tab.dataset.view));
      });
      
      // Mode toggle
      document.querySelectorAll('.mode-btn').forEach(btn => {
        btn.addEventListener('click', () => setStudyMode(btn.dataset.mode));
      });
      
      // Keyboard
      document.addEventListener('keydown', (e) => {
        if (document.getElementById('study-view').classList.contains('active')) {
          if (e.key === ' ' && studyMode === 'flip') {
            e.preventDefault();
            flipCard();
          } else if (e.key === 'ArrowRight') {
            nextCard();
          } else if (e.key === 'ArrowLeft') {
            prevCard();
          } else if (e.key === 'Enter' && studyMode === 'type') {
            checkAnswer();
          }
        }
      });
      
      // Touch swipe
      let touchStartX = 0;
      document.getElementById('flashcard-container').addEventListener('touchstart', (e) => {
        touchStartX = e.touches[0].clientX;
      });
      
      document.getElementById('flashcard-container').addEventListener('touchend', (e) => {
        const diff = e.changedTouches[0].clientX - touchStartX;
        if (Math.abs(diff) > 50) {
          if (diff > 0) prevCard();
          else nextCard();
        }
      });
    }

    // Register service worker with force update
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('./sw.js').then(registration => {
        // Check for updates every time page loads
        registration.update();
        
        // When new service worker is found, activate it immediately
        registration.addEventListener('updatefound', () => {
          const newWorker = registration.installing;
          newWorker.addEventListener('statechange', () => {
            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
              // New version available - force activate
              newWorker.postMessage('skipWaiting');
              // Reload to get new version
              window.location.reload();
            }
          });
        });
      });
      
      // Reload when new service worker takes control
      navigator.serviceWorker.addEventListener('controllerchange', () => {
        window.location.reload();
      });
    }

    // Start app
    init();
  </script>
</body>
</html>
